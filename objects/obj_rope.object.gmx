<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>anchor = true;


chainlength = 500;
chainlinks = 10;
next = noone;
last = self;

grav = 16;
air_res = 0.99;
dt = .15;


//repeat(chainlinks){
for ( i = 0; i&lt;chainlinks; i++){
    //position of chain link
    link_x = last.x;
    link_y = last.y + chainlength/chainlinks;
    new = instance_create(link_x,link_y,obj_link);
    new.length = chainlength/chainlinks;
    //if (last == self) new.angle = 1;
    //set parent and child of old and new chain links
    new.color = make_colour_rgb(255*(i/chainlinks),255*(1-i/chainlinks),0);
    new.prev = last;
    new.old_x = new.x;
    new.old_y = new.y;
    last.next = new;
    last = new;
    links[i] = new;
}
last.mass = 20;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//movement
x = parent.x;
y = parent.y;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///rope loop
//apply physics to all segments
for(i = 0; i&lt;chainlinks; i++){
    links[i].vel_y += grav * dt;
    links[i].x += links[i].vel_x * dt;
    links[i].y += links[i].vel_y * dt;
}
//move segments towards their intended length
for(i = 0; i&lt;chainlinks; i++){
    dist = point_distance(links[i].prev.x,links[i].prev.y,links[i].x,links[i].y);
    //if( dist !=0 ){
    if( dist &gt; links[i].length ){
        correction_x = (links[i].length/dist - 1.0) * ( links[i].x - links[i].prev.x );
        correction_y = (links[i].length/dist - 1.0) * ( links[i].y - links[i].prev.y );
        //if (links[i].prev.anchor &amp;&amp; links[i].anchor)
        if (links[i].prev.anchor){
            links[i].x += 1.0 * correction_x;
            links[i].y += 1.0 * correction_y;
        //else if (links[i].anchor)
        } else{
            //totalmass = links[i].prev.mass + links[i].mass;
            //ratio_a = links[i].prev.mass/totalmass;
            //ratio_b = links[i].mass/totalmass;
            ratio_a = 0.5;
            ratio_b = 0.5;
            links[i].prev.x -= ratio_a * correction_x;
            links[i].prev.y -= ratio_a * correction_y;
            links[i].x += ratio_b * correction_x;
            links[i].y += ratio_b * correction_y;
        }   
    }
}
//make sure the full rope is within the maxlength
//note: should be done for each anchor, change later
totaldist = point_distance(links[0].x,links[0].y, links[chainlinks-1].x,links[chainlinks-1].y)
if(totaldist&gt;chainlength){    
        correction_x = (chainlength/totaldist - 1.0) * ( links[chainlinks-1].x - links[0].prev.x );
        correction_y = (chainlength/totaldist - 1.0) * ( links[chainlinks-1].y - links[0].prev.y );
        anchor = links[0].prev;
            for(i = 0; i&lt;chainlinks; i++){
                dist = point_distance(anchor.x,anchor.y,links[i].x,links[i].y)
                links[i].x += dist/totaldist * correction_x;
                links[i].y += dist/totaldist * correction_y;
                //if (links[i].prev.anchor &amp;&amp; links[i].anchor)
                if (links[i].prev.anchor){
                    //links[i].x += 1.0 * correction_x;
                    //links[i].y += 1.0 * correction_y;
                    //else if (links[i].anchor)
                } else{
                }
        }
}

//find their velocities for the next loop
for(i = 0; i&lt;chainlinks; i++){
    links[i].vel_x = (links[i].x - links[i].old_x)/dt;
    links[i].vel_y = (links[i].y - links[i].old_y)/dt;
    
    links[i].old_x = links[i].x;
    links[i].old_y = links[i].y;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
