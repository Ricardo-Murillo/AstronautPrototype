<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// set default values for chain's variables 
// author: Ricardo Murillo

enum anchor_points {
    neither,
    start,
    last,
    both,
}
drawguides = false;

length = 300;
segments = 20;
grav = 16;
dt = 0.15;
anchor = anchor_points.start;
start = noone
last = noone;

start_x = 0;
start_y = 0;
start_oldx = 0;
start_oldy = 0;
start_vx = 0;
start_vy = 0;

p1_angle = 0;
p1_x = 0;
p1_y = 0;
p1_oldx = 0;
p1_oldy = 0;
p1_vx = 0;
p1_vy = 0;

p2_angle = 0;
p2_x = 0;
p2_y = 0;
p2_oldx = 0;
p2_oldy = 0;
p2_vx = 0;
p2_vy = 0;


last_x = 0;
last_y = 0;
last_oldx = 0;
last_oldy = 0;
last_vx = 0;
last_vy = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///calculate velocities
//start_vx = (start_x - start_oldx)/dt;
//start_vy = (start_y - start_oldy)/dt;
//start_oldx = start_x;
//start_oldy = start_y;
//start_x = start.x;
//start_y = start.y;

p1_vx = (p1_x - p1_oldx)/dt;
p1_vy = (p1_y - p1_oldy)/dt;
p1_oldx = p1_x;
p1_oldy = p1_y;

p2_vx = (p2_x - p2_oldx)/dt;
p2_vy = (p2_y - p2_oldy)/dt;
p2_oldx = p2_x;
p2_oldy = p2_y;


if(!object_exists(start)){
    start_vy += grav *dt;
}
//start_x = start.x;
//start_y = start.y;

if(!object_exists(last)){
    //last object now does the calculations, please use last.old_x and last.vel_x 
    last_vx = (last_x - last_oldx)/dt;
    last_vy = (last_y - last_oldy)/dt;
    last_oldx = last_x;
    last_oldy = last_y;
}
//last_x = last.x;
//last_y = last.y;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///move chain elements based on local velocities 
// author: Ricardo Murillo

dt = delta_time/100000;
if(keyboard_check_pressed(vk_tab)){
    drawguides = !drawguides;
}
//start_vy += grav *dt;
//start_x = start.x;
//start_y = start.y;

p1_vy += grav *dt;
p1_x += p1_vx * dt;
p1_y += p1_vy * dt;  

p2_vy += grav *dt;
p2_x += p2_vx * dt;  
p2_y += p2_vy * dt;  

if(!object_exists(last)){
    last_vy += grav *dt;
    last_vx *= 0.99;
    last_x += last_vx * dt;  
    last_y += last_vy * dt;  
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///check if the points of the chain are within the bounds, if not, correct
//      if the chain ends are bound to other objects, use those values
// author: Ricardo Murillo

if(instance_exists(start)){
    start_x = start.x ;
    start_y = start.y;
    //clear tension
    ds_map_delete(start.forces, "tension");
}
if(instance_exists(last)){
    last_x = last.x;
    last_y = last.y;
    //clear tension
    ds_map_delete(last.forces, "tension");
}
var dist = point_distance(start_x,start_y,last_x,last_y);
var at_edge = false;
//determine if the chain's length is outside of the chain's bounds
if(dist&gt;length){
    at_edge = true;
    //forces
    if(instance_exists(start)&amp;&amp;(instance_exists(last))){
        //get all forces
        var netforce_start = calculate_forces(start)
        var netforce_last = calculate_forces(last)
        if (vector_sum(netforce_start)!=0 &amp;&amp; vector_sum(netforce_last)!=0){
            //find forces that are &gt;90 deg from tension direction
            //project them to tension direction and add together
            //show_debug_message("non-zero");
            
        }
     }
    //calculate length correction
    var correction_x = (length/dist - 1.0) * ( last_x - start_x );
    var correction_y = (length/dist - 1.0) * ( last_y - start_y );
    
    //determine weights to apply to the corrective forces
    //larger weight means that that end gets pulled more
    var sx_weight = 0; 
    var sy_weight = 0; 
    var lx_weight = 0; 
    var ly_weight = 0; 
    //anchors_points are which which end of the rope is immobile
    if anchor == anchor_points.start {
        //determine how much of a given distance an object is capable of traveling
        //lx_slack = min(1.0,check_anchor_slack(last,0,0,correction_x,'x')); 
        //ly_slack = min(1.0,check_anchor_slack(last,lx_slack,0,correction_y,'y'));
        lx_slack = check_anchor_slack(last,0,0,correction_x,'x'); 
        ly_slack = check_anchor_slack(last,lx_slack,0,correction_y,'y');
        //lx_slack = correction_x;
        //ly_slack = correction_y;
        // distance the object can travel / distance the object needs to travel
        if (correction_x != 0) lx_weight = lx_slack/correction_x;
        if (correction_y != 0) ly_weight = ly_slack/correction_y;
        
        if(instance_exists(start)){
            
        }
        if(instance_exists(last)){
            
        }
    } else if anchor == anchor_points.last {
        sx_slack = min(1.0,check_anchor_slack(start,0,0,-correction_x,'x')); 
        sy_slack = min(1.0,check_anchor_slack(start,sx_slack,0,-correction_y,'y'));
        
        if (correction_x != 0) sx_weight = sx_slack/(-correction_x);
        if (correction_x != 0) sy_weight = sy_slack/(-correction_y);
    } else if anchor == anchor_points.neither {
        //determine how much of a given distance an object is capable of traveling
        //start's slack along x axis
        var sxs = check_anchor_slack(start,0,0,-correction_x,'x');
        var sys = check_anchor_slack(start,sxs,0,-correction_y,'y');
        var lxs = check_anchor_slack(last,0,0,correction_x,'x');
        var lys = check_anchor_slack(last,lxs,0,correction_y,'y');

        
        // distance the object can travel / distance the object needs to travel 
        //start's weight along the x axis

        var sxw = 0;
        if (correction_x != 0) sxw = sxs/(-correction_x);
        var lxw = 0;
        if (correction_x != 0) lxw = lxs/correction_x;
        
        var syw = 0
        if (correction_y != 0) syw = sys/(-correction_y);
        var lyw = 0
        if (correction_y != 0) lyw = lys/correction_y;
        
        //objects with smaller masses get pulled more by more massive objects
        var weight_x = 0.5;
        var weight_y = 0.5;/*
        //find and apply friction
        if (instance_exists(start) &amp;&amp; instance_exists(last)){
            //var totalmass = start.mass + last.mass;
            //default_weight = (totalmass - start.mass)/totalmass;
            //var dt2 = power(dt,2); //should multiply accelerations(correction_x) by dt^2
            var f_netx_start = abs(friction_modifier_x(start,-correction_x*last.mass,(-correction_y - sys)*last.mass));
            var f_netx_last = abs(friction_modifier_x(last,correction_x*start.mass,(correction_y - lys)*start.mass));
            var f_nety_start = abs(friction_modifier_y(start,(-correction_x - sxs)*last.mass,-correction_y*last.mass));
            var f_nety_last = abs(friction_modifier_y(last,(correction_x - lxs)*start.mass,correction_y*start.mass));
            if ((f_netx_start + f_netx_last) != 0)
                weight_x = f_netx_start/(f_netx_start + f_netx_last);
            if ((f_nety_start + f_nety_last) != 0)
                weight_y = f_nety_start/(f_nety_start + f_nety_last);
        }*/
        //compensate if one object can't move their full distance
        if ((sxw &gt;= weight_x) &amp;&amp; (lxw &gt;= 1.0 - weight_x)){
            sx_weight = weight_x; 
            lx_weight = 1.0 - weight_x; 
        } else{
            if (sxw&lt;lxw){
                sx_weight = sxw; 
                lx_weight = min(lxw,1.0 - sxw); 
            }else{ 
                sx_weight = min(sxw,1.0 - lxw); 
                lx_weight = lxw;
            }
        }
        if ((syw &gt;= weight_y) &amp;&amp; (lyw &gt;= 1.0 - weight_y)){
            sy_weight = weight_y; 
            ly_weight = 1.0 - weight_y; 
        } else{
            if (syw&lt;lyw){
                sy_weight = syw; 
                ly_weight = min(lyw,1.0 - syw); 
            }else{ 
                sy_weight = min(syw,1.0 - lyw); 
                ly_weight = lyw;
            }
        }
    }
    //apply the velocities to the right places
    if(instance_exists(start)){
        start.x -= sx_weight * correction_x;
        start.y -= sy_weight * correction_y;
        start_x = start.x;
        start_y = start.y;
    }else{
        start_x -= sx_weight * correction_x;
        start_y -= sy_weight * correction_y;
    }
    if(instance_exists(last)){
        last.x += lx_weight * correction_x;
        last.y += ly_weight * correction_y;
        last_x = last.x;
        last_y = last.y;
    }else{
        last_x += lx_weight * correction_x;
        last_y += ly_weight * correction_y;
    }
}
r = dist/length;
pr = 1/3;
//mr = power(length/(dist+0.01),3)*(1-2*pr)/2;
mr = (1-2*pr)/3
//mr = 1/3;
dist = point_distance(p1_x,p1_y,p2_x,p2_y);
if(dist &gt; (length*mr)){
    correction_x = ((length*mr)/dist - 1.0) * ( p2_x - p1_x );
    correction_y = ((length*mr)/dist - 1.0) * ( p2_y - p1_y );
    p1_x -= 0.5*(r) * correction_x;
    p1_y -= 0.5*(r) * correction_y;
    p2_x += 0.5*(r) * correction_x;
    p2_y += 0.5*(r) * correction_y;
}

dist = point_distance(start_x,start_y,p1_x,p1_y);
if(dist &gt; pr*length){
    correction_x = ((length*pr)/dist - 1.0) * ( p1_x - start_x );
    correction_y = ((length*pr)/dist - 1.0) * ( p1_y - start_y );
    p1_x += 1.0 * correction_x;
    p1_y += 1.0 * correction_y;
}
dist = point_distance(last_x,last_y,p2_x,p2_y);
if(dist &gt; pr*length){
    correction_x = ((length*pr)/dist - 1.0) * ( p2_x - last_x );
    correction_y = ((length*pr)/dist - 1.0) * ( p2_y - last_y );
    p2_x += 1.0 * correction_x;
    p2_y += 1.0 * correction_y;
}
if(instance_exists(start)){
    start.tension_angle = -point_direction(start.x,start.y,last_x,last_y)*pi/180;
    
}
if(instance_exists(last)){
    last.tension_angle = -point_direction(last.x,last.y,start_x,start_y)*pi/180;
    if(at_edge){
        if(anchor == anchor_points.start){
            ds_map_delete(last.forces, "tension");
            //calculate new acceleration
            var s_forces = calculate_forces(start);
            var s_force_pl = s_forces[1]*sin(last.tension_angle) - s_forces[0]*cos(start.tension_angle);
            //var s_force_pp = s_forces[1]*cos(last.tension_angle) + s_forces[0]*sin(start.tension_angle);
            
            var l_forces = calculate_forces(last);
            var l_force_pl = l_forces[1]*sin(last.tension_angle) - l_forces[0]*cos(last.tension_angle);
            var l_force_pp = l_forces[1]*cos(last.tension_angle) + l_forces[0]*sin(last.tension_angle);
            var l_acc_pl = s_force_pl/start.mass;
            var l_acc_pp = l_force_pp/last.mass;
            var l_acc_x = l_acc_pp * sin(last.tension_angle) - l_acc_pl * cos(last.tension_angle);
            var l_acc_y = l_acc_pp * cos(last.tension_angle) + l_acc_pl * sin(last.tension_angle);
            if (l_force_pl &lt; 0){
            
            }
            //show_debug_message("(" + string(last.vel_x) +", " + string(last.vel_y) + ")");
            var chain_angle = last.tension_angle - pi;
            var tension = -last.mass * last.grav_acc * sin(chain_angle);
            var tension_force = array(tension*cos(chain_angle),tension*sin(chain_angle));
            var net_force = calculate_forces(last);
            if(dot_product(net_force[0],net_force[1],cos(last.tension_angle),sin(last.tension_angle))&lt;0){
                last.forces[? "tension"] =  tension_force;
                //var acc_tx = tension_force[0]/last.mass;
                //var acc_ty = tension_force[1]/last.mass;
                //last.vel_x += acc_tx*last.dt;
                //last.vel_y += acc_ty*last.dt;
            }
            var vel_angle = -point_direction(0,0,last.vel_x,last.vel_y)*pi/180;
            var ang = last.tension_angle+pi/2 - vel_angle;
            var vel_dist = point_distance(0,0,last.vel_x,last.vel_y);
            var vel_proj = vel_dist*cos(ang);
            last.vel_x = vel_proj*cos(last.tension_angle+pi/2);
            last.vel_y = vel_proj*sin(last.tension_angle+pi/2);
            
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw chains
// author: Ricardo Murillo

var guideColor1 = make_colour_rgb(255,0,0);
var guideColor2 = make_colour_rgb(0,255,0);
var guideColor3 = make_colour_rgb(0,0,255);
var guideColor4 = make_colour_rgb(0,0,0);

if(drawguides){
    draw_line_width_colour(start_x,start_y,p1_x,p1_y,5,guideColor2,guideColor2);
    draw_line_width_colour(last_x,last_y,p2_x,p2_y,5,guideColor3,guideColor3);
    draw_line_colour(start_x,start_y,last_x,last_y,guideColor1,guideColor1);
    draw_line_colour(p1_x,p1_y,p2_x,p2_y,guideColor4,guideColor4);
}
//draw_line_width_colour
//draw_line_colour(


//var color1 = make_colour_rgb();
draw_set_colour(c_dkgray);
for(i = 0;i&lt;segments;i++){
    t = i/(segments);
    r = length/(segments*2);
    draw_circle(get_bezier(start_x,p1_x,p2_x,last_x,t),
                get_bezier(start_y,p1_y,p2_y,last_y,t),
                r,true);
    //draw_line_colour(

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
