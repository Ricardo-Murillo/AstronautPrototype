<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_link</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>obj_pickup</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// set default values for obj_weight's variables 
// author: Ricardo Murillo
event_inherited();

mass = 19;
dt = 0.15;
grav = 64;
grav_acc = 16;
acc_y = grav_acc;

forces[? "gravity"] = mult_vector(array(0,grav_acc),mass);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_map_destroy(forces);
//chain.last = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///recalculate velocity since chain might have moved it
// author: Ricardo Murillo
//apply_approach_wall(self);
//calculate_velocity(self);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///move obj_weight based on local velocities and collisions 
// author: Ricardo Murillo

dt = delta_time/100000;
move_x = mouse_x - x;
move_y = mouse_y - y;

if(mouse_check_button_pressed(mb_left)){
    if (instance_position( mouse_x, mouse_y, self )){
        mobile_state = true;
    }
}
if(mouse_check_button_released(mb_left))
    mobile_state = false;

vel_x += acc_x*dt;
vel_y += acc_y*dt;
//if (vel_y &gt; grav)
//    vel_y = grav; 
//if (place_meeting(x,y+1,collisionblock)){
//    vel_x *= 0.9;
//}
if (mobile_state){
   vel_x = move_x/dt;
   vel_y = move_y/dt;
}
//apply_approach_wall(self)
acc_x = 0;
acc_y = grav_acc;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if !chained
    //apply_approach_wall(self);
with(obj_1way) {
    //var other_x = round(other.x + (other.sprite_width/2)-1);
    var other_x = other.x;
    var other_y = round(other.y + (other.sprite_height/2)-1);
    //if( other_y &gt; y)// or if down button?
    if(bool_1way(self,other,false))
    {
        //show_debug_message("hello: "+string(self.id));
        //sprite_index = spr_1way_temp;
        //sprite_index = -1;
        mask_index = -1;
    }
    else{
        mask_index = self.collisionmask;
    }
}
var ramp_height = 5;
var dx = vel_x*dt;
var dy = vel_y*dt;
/*var steps;
var ix;
var iy;
if (dx ==0 &amp;&amp; dy==0){
    steps = 0;
}
else if (abs(dx)&gt;abs(dy)){
    steps = ceil(abs(dx));
    ix = sign(dx);
    iy = sign(dy)*abs(dy/dx);
}
else{
    steps = ceil(abs(dy));
    ix = sign(dx)*abs(dx/dy);
    iy = sign(dy);
}*/
var xk = x;
var yk = y;
//var ramp_corr = approach_wall_y(self,0,0,-ramp_height,collisionblock);
//y += ramp_corr;
var x_focus = true; //if the focus is on x-steps or y-steps
var m = 0;
var c = 0;
if abs(dx) &gt;= abs(dy){ //if angle &lt;= 45 deg
    m = dy/dx; // slope
    c = y - m*x; // y-intercept
}
else{ //if angle &gt; 45 deg
    x_focus = false; 
    m = dx/dy; // 1/slope
    c = x - m*y; // x-intercept
}
while !(dx == 0 &amp;&amp; dy == 0) {
    //calc step
    var ix = sign(dx)*min(abs(dx),1);
    var iy = sign(dy)*min(abs(dy),1);
    var ix_err = 0;
    var iy_err = 0;
    // calculate where it should be minus where it is
    if x_focus{
        ix_err = abs((m*(x+ix)+c) - y); 
        iy_err = abs((m*x+c) - (y+iy)); 
    }else{ 
        ix_err = abs((m*y+c) - (x+ix));
        iy_err = abs((m*(y+iy)+c) - x); 
    }
    if ix_err == iy_err{
        if abs(ix) &gt; abs(iy){
            //do nothing to ix
            iy = 0;
        } else{
            ix = 0;
            //do nothing to iy
        }
    }
    else if ix_err &lt; iy_err { //if ix is closer to line, move to x + ix
        //do nothing to ix
        iy = 0;
    } else{
        ix = 0;
        //do nothing to iy
    }
    var inst = instance_place(x+ix, y+iy, collisionblock);
    if inst != noone { //if collision
        if (ix != 0){
            vel_x = -vel_x*inst.bounce;
            vel_y -= vel_y * inst.fric;
        }
        if (iy != 0){
            vel_x -= vel_x * inst.fric;
            vel_y = -vel_y*inst.bounce;
            if (abs(vel_y) &lt; 1.0) vel_y = 0;
        }
        break;
    }
    x += ix;
    dx -= ix;
    y += iy;
    dy -= iy;
}
/*
//repeat (ceil(abs(dx))) {
while (dx != 0){
    var ix = sign(dx)*min(abs(dx),1);
    //if (place_meeting(x+ix, y, collisionblock)){
    var inst = instance_place(x+ix, y, collisionblock);
    if inst != noone {
        vel_x = -vel_x*inst.bounce;
        vel_y -= vel_y * inst.fric;
        //if (abs(vel_x) &lt; 1.0) vel_x = 0;
        break;
    }
    x += ix;
    dx -= ix;
}
//var ramp_corr = approach_wall_y(self,0,0,-ramp_corr,collisionblock);
//y += ramp_corr;
//repeat (ceil(abs(dy))) {
while (dy != 0){
    var iy = sign(dy)*min(abs(dy),1);
    //if (place_meeting(x, y+iy, collisionblock)){
    var inst = instance_place(x, y+iy, collisionblock);
    if inst != noone {
        vel_x -= vel_x * inst.fric;
        vel_y = -vel_y*inst.bounce;
        if (abs(vel_y) &lt; 1.0) vel_y = 0;
        break;
    }
    y += iy;
    dy -= iy;
}
*/
/*repeat (steps){
    if (place_meeting(x+round(ix), y+round(iy), collisionblock)){
        vel_x = 0;
        vel_y = 0;
        break;
    }
    x += ix;
    y += iy;
}*/
/*repeat (steps){
    x = round(xk);
    y = round(yk);
    xk += ix;
    yk += iy;
    if (place_meeting(round(xk), round(yk), collisionblock)){
        vel_x = 0;
        vel_y = 0;
        break;
    }
}*/
/*
//H collision
var dx;
if (vel_y&gt;0){ //going down
    var a = approach_wall_y(self,0,0,-ramp_height,collisionblock);
    y += a;
    dx = approach_wall_x(self,0,0,vel_x*dt,collisionblock)   
    if abs(dx)&lt; abs(vel_x*dt) vel_x = 0;
    x += dx;
    var b = approach_wall_y(self,0,0,ramp_height-a,collisionblock);
    y += b;
    if b==ramp_height-a{
       a = approach_wall_y(self,0,0,-ramp_height,collisionblock);
       y += a;
    }
}else if (vel_y&lt;0){
    var a = approach_wall_y(self,0,0,ramp_height,collisionblock);
    y += a;
    dx = approach_wall_x(self,0,0,vel_x*dt,collisionblock)   
    if abs(dx)&lt; abs(vel_x*dt) vel_x = 0;
    x += dx;
    a = approach_wall_y(self,0,0,-ramp_height,collisionblock);
    y += a;
}
else{
    var dx = approach_wall_x(self,0,0,vel_x*dt,collisionblock)   
    if abs(dx)&lt; abs(vel_x*dt){
        vel_x = 0;
    }
    x += dx;
}
//V collision
var old_vel_y = vel_y;
var dy = approach_wall_y(self,0,0,vel_y*dt,collisionblock);   
if abs(dy)&lt; abs(vel_y*dt){
     vel_y = 0;
     if (old_vel_y &gt;0)  state = states.grounded;
}
y += dy;
*/
with(obj_1way) {
    //sprite_index = spr_1way;
    mask_index = self.collisionmask;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
//if drawguides {}
draw_forces(self);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
